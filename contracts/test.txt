
contract BrokenPepe is ERC20, Ownable {
    using Address for address payable;

    IRouter public router;
    address public pair;

    uint256 public tokenLiquidityThreshold = 1; //50_000_000_000 * 1e18; //50_000_000_000 tokens = 0.05% of Total Supply

    bool private _liquidityMutex = false;
    bool public providingLiquidity = false;

    address public team = 0x70997970C51812dc3A010C7d01b50e0d17dc79C8;
    address public marketing = 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC;
    address public stakingReserve = 0x90F79bf6EB2c4f870365E785982E1f101E93b906;
    address public bottleCapReserve =
        0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65;
    address public taxReserve = 0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc;

    uint256 public teamAllocation;
    uint256 public marketingAllocation;
    uint256 public stakingAllocation;
    uint256 public bottleCapAllocation;

    uint256 public genesis_block;

    address public routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; //uniswapv2

    mapping(address => bool) public exemptFee;
    mapping(address => bool) public isBlacklisted;

    // AntiDump
    mapping(address => uint256) private _lastSell;
    bool public coolDownEnabled = true;
    uint256 public coolDownTime = 120 seconds;

    uint256 fee;

    // Antiloop
    modifier mutexLock() {
        if (!_liquidityMutex) {
            _liquidityMutex = true;
            _;
            _liquidityMutex = false;
        }
    }

    constructor() ERC20("Broken Pepe", "BPP") {
        uint256 totalSupply = 100_000_000_000_000 * (10 ** decimals()); //1T

        // Initial allocation of tokens
        teamAllocation = (totalSupply * 10) / 100; // 10%
        marketingAllocation = (totalSupply * 7) / 100; // 7%
        stakingAllocation = (totalSupply * 20) / 100; // 20%
        bottleCapAllocation = (totalSupply * 3) / 100; // 3%

        uint256 publicAllocation = totalSupply -
            teamAllocation -
            marketingAllocation -
            stakingAllocation -
            bottleCapAllocation;

        //Mint tokens
        // Transfer allocations
        _mint(team, teamAllocation);
        _mint(marketing, marketingAllocation);
        _mint(stakingReserve, stakingAllocation);
        _mint(bottleCapReserve, bottleCapAllocation);
        _mint(msg.sender, publicAllocation);

        //Define Router
        IRouter _router = IRouter(routerAddress);

        //Create a pair for this new token
        address _pair = IFactory(_router.factory()).createPair(
            address(this),
            _router.WETH()
        );

        //Define router and pair to variables
        router = _router;
        pair = _pair;

        //Add exceptions
        exemptFee[msg.sender] = true;
        exemptFee[address(this)] = true;
        exemptFee[team] = true;
        exemptFee[marketing] = true;
        exemptFee[stakingReserve] = true;
        exemptFee[bottleCapReserve] = true;
        exemptFee[taxReserve] = true;
    }

    function approve(
        address spender,
        uint256 amount
    ) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public override returns (bool) {
        _transfer(sender, recipient, amount);

        uint256 currentAllowance = _allowances[sender][_msgSender()];
        require(
            currentAllowance >= amount,
            "ERC20: transfer amount exceeds allowance"
        );
        _approve(sender, _msgSender(), currentAllowance - amount);

        return true;
    }

    function increaseAllowance(
        address spender,
        uint256 addedValue
    ) public override returns (bool) {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender] + addedValue
        );
        return true;
    }

    function decreaseAllowance(
        address spender,
        uint256 subtractedValue
    ) public override returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        require(
            currentAllowance >= subtractedValue,
            "ERC20: decreased allowance below zero"
        );
        _approve(_msgSender(), spender, currentAllowance - subtractedValue);

        return true;
    }

    function transfer(
        address recipient,
        uint256 amount
    ) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal override {
        require(
            amount > 0,
            "Broken Pepe: Transfer amount must be greater than zero"
        );
        require(
            !isBlacklisted[sender] && !isBlacklisted[recipient],
            "Broken Pepe: Blacklisted"
        );

        if (recipient == pair && genesis_block == 0)
            genesis_block = block.number;

        if (
            sender != pair &&
            !exemptFee[recipient] &&
            !exemptFee[sender] &&
            !_liquidityMutex
        ) {
            if (coolDownEnabled) {
                uint256 timePassed = block.timestamp - _lastSell[sender];
                require(
                    timePassed >= coolDownTime,
                    "Broken Pepe: Cooldown enabled"
                );
                _lastSell[sender] = block.timestamp;
            }
        }

        uint256 feeswap;
        //Set fee to 0 if fees in contract are Handled or Exempted
        if (_liquidityMutex || exemptFee[sender] || exemptFee[recipient]) {
            fee = 0;
        } else if (recipient == pair || sender != pair) {
            //sell or between non excluded accounts
            feeswap = calculateFee();
        }

        // Fee -> total amount of tokens to be substracted
        fee = (amount * feeswap) / 10_000;

        if (sender != pair && feeswap > 0) {
            handle_fees(feeswap); //transfer fee to taxReserve
        }

        super._transfer(sender, recipient, amount - fee); //transfer to recipient amount minus fees
    }

    function handle_fees(uint256 feeswap) private mutexLock {
        uint256 tokenBalance = balanceOf(address(this));

        if (tokenBalance >= tokenLiquidityThreshold) {
            //Check if threshold is 0 and set it to balance
            if (tokenLiquidityThreshold != 0) {
                tokenBalance = tokenLiquidityThreshold;
            }

            //Swap
            swapTokensForETH((tokenBalance * feeswap) / 10_000); //swap the eth fees
            uint256 ethBalance = address(this).balance;

            //Send the eth fee to the taxReserve
            payable(taxReserve).sendValue(ethBalance);
        }
    }

    function swapTokensForETH(uint256 tokenAmount) private {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.WETH();

        _approve(address(this), address(router), tokenAmount);

        router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function calculateFee() public view returns (uint256) {
        uint256 _balance = balanceOf(msg.sender);
        if (_balance <= 50_000_000 * (10 ** 18)) {
            return 1000; // represents 10.00%
        } else if (_balance <= 500_000_000 * (10 ** 18)) {
            return 750; // represents 7.50%
        } else if (_balance <= 900_000_000 * (10 ** 18)) {
            return 500; // represents 5.00%
        } else if (_balance <= 1_500_000_000 * (10 ** 18)) {
            return 250; // represents 2.50%
        } else {
            return 0;
        }
    }

    function setLiquidityProvide(bool _state) external onlyOwner {
        providingLiquidity = _state;
    }

    function setLiquidityThreshold(
        uint256 _newLiquidityThreshold
    ) external onlyOwner {
        require(
            _newLiquidityThreshold != 0,
            "MrETH: Liquidity threshold can't be 0"
        );
        tokenLiquidityThreshold = _newLiquidityThreshold * 1e18;
    }

    function setRouterAndPair(
        address _newRouter,
        address _newPair
    ) external onlyOwner {
        require(_newRouter != address(0), "MrETH: Router is the zero address");
        require(_newPair != address(0), "MrETH: Pair is the zero address");
        router = IRouter(_newRouter);
        pair = _newPair;
    }

    function setCooldown(bool _state, uint256 time) external onlyOwner {
        require(time <= 90, "MrETH: Cooldown is above 90 seconds.");
        coolDownTime = time * 1 seconds;
        coolDownEnabled = _state;
    }

    function setIsBlacklisted(
        address _account,
        bool _state
    ) external onlyOwner {
        require(_account != address(0), "MrETH: Owner can't be blacklisted.");
        isBlacklisted[_account] = _state;
    }

    function setBulkIsBlacklisted(
        address[] calldata accounts,
        bool _state
    ) external onlyOwner {
        for (uint256 i = 0; i < accounts.length; ) {
            isBlacklisted[accounts[i]] = _state;
            unchecked {
                i++;
            }
        }
    }

    function setExemptFee(address _address, bool _state) external onlyOwner {
        exemptFee[_address] = _state;
    }

    function setBulkExemptFee(
        address[] calldata accounts,
        bool _state
    ) external onlyOwner {
        for (uint256 i = 0; i < accounts.length; ) {
            exemptFee[accounts[i]] = _state;
            unchecked {
                i++;
            }
        }
    }

    function getPair() public view returns (address) {
        return pair;
    }

    function rescueETH() external onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }

    function rescueBEP20(
        address _tokenAddress,
        uint256 _amount
    ) external onlyOwner {
        IERC20(_tokenAddress).transfer(_tokenAddress, _amount);
    }

    receive() external payable {}
}

1 - test that the initial distribution of tokens is ok
2 - test that when an excluded account transfer to another account it does not get taxed
3 - test that when an account that is not excluded transfer to another account it gets taxed
4 - test that when the tokenLiquidityThreshold is met and an account is not excluded from the transfer the eth fees are transfered to taxReserve account